import java.util.*;
import java.io.*;

import twitter4j.Twitter;
import twitter4j.TwitterException;
import twitter4j.TwitterFactory;
import twitter4j.auth.*;
import twitter4j.conf.*;

public class TweetDraftsBackend {
	
	private TwitterFactory tf;
	private Twitter twitter;
	
	private String dataBasePath;
	final char confSeparator = '=';
	
	private boolean isInitialized;
	
	private OAuthTokens oauth;
	private ArrayList<String> drafts;
	
	public TweetDraftsBackend() {
		this("data/");
	}
	
	public TweetDraftsBackend(String configPath) {
		dataBasePath = new String(configPath);
		isInitialized = false;
		drafts = new ArrayList<String>();
		oauth = new OAuthTokens();
	}
	
	public boolean loadDataFromDisk() {
		Debug.println("Loading data from disk.");
		if (isInitialized) {
			Debug.println("Already initialized. Didn't load data again.");
			return isInitialized;
		}
		
		try {
			String path = dataBasePath + "index.txt";
			Debug.println("Trying to open " + path);
			Scanner config = new Scanner(new File(path));
			Debug.println("Opening succeeded.");
			// import data from config.
			
			// fuck regex
			//String regex = "^*=*";
			// Regex generated by http://www.txt2re.com
			//String regex = "((?:[a-z][a-z]+))(=)((?:[a-z][a-z]+))";
			while (config.hasNextLine()) {
				Debug.println("Has next line.");
				String buf = config.nextLine();
				Debug.println("Got line from config: " + buf);
				String data, type;
				
				int i_separator = buf.indexOf(confSeparator);
				
				if (i_separator == -1) {
					Debug.println("That line is invalid.");
					continue;
				}
				else {
					type = buf.substring(0, i_separator);
					data = buf.substring(i_separator + 1);
					Debug.println("Parsed: " + type + ", " + data);
				}
				
				Debug.print("Matched: ");
				if (type.equals("OAuth/ConsumerKey")) {
					oauth.consumerKey = data;
					Debug.print("oauth.consumerKey");
				}
				else if (type.equals("OAuth/ConsumerSecret")) {
					oauth.consumerSecret = data;
					Debug.print("oauth.consumerSecret");
				}
				else if (type.equals("OAuth/AccessToken")) {
					oauth.accessToken = data;
					Debug.print("oauth.accessToken");
				}
				else if (type.equals("OAuth/AccessTokenSecret")) {
					oauth.accessTokenSecret = data;
					Debug.print("oauth.accessTokenSecret");
				}
				else if (type.equals("DraftPath")) {
					// TODO: does this need protection from loadDraft() returning null?
					String draft = loadDraft(dataBasePath + data);
					if (draft != null) {
						drafts.add(draft);
					}
					Debug.print("draft");
				}
				else {
					Debug.print("none");
				}
				
				Debug.println("");
			}
			Debug.println("Done reading index file.");
		}
		catch (IOException e) {
			Debug.println("Can't open index file.");
		}
		
		if (oauth.isComplete()) {
			isInitialized = initTwitterObjs();
			Debug.println("OAuth has all keys");
		}
		
		return isInitialized;
	}
	
	private String loadDraft(String path) {
		String draft = "";
		
		try {
			Scanner data = new Scanner(new File(path));
			while (data.hasNextLine()) {
				draft += data.nextLine() + '\n';
			}
			Debug.println("loaded draft: " + draft);
		}
		catch (IOException e) {
			draft = null;
			Debug.println("(empty)");
		}
		
		return draft;
	}
	
	public OAuthTokens setOAuthTokens(OAuthTokens tokens) {
		if (isInitialized) {
			return null;
		}
		
		OAuthTokens oldTokens = oauth;
		oauth = tokens;
		initTwitterObjs();
		isInitialized = oauth.isComplete();
		
		return oldTokens;
	}
	
	public boolean initTwitterObjs() {
		Debug.print("initTwitterObjs ");
		if (!oauth.isComplete()) {
			Debug.println("fail");
			return false;
		}
		
		ConfigurationBuilder cb = new ConfigurationBuilder();
		cb.setDebugEnabled(Debug.isDebug)
		  .setUseSSL(true)
		  .setOAuthConsumerKey(oauth.consumerKey)
		  .setOAuthConsumerSecret(oauth.consumerSecret)
		  .setOAuthAccessToken(oauth.accessToken)
		  .setOAuthAccessTokenSecret(oauth.accessTokenSecret)
		  .setMediaProvider("imgly")
		;
		tf = new TwitterFactory(cb.build());
		try {
			twitter = tf.getInstance();
		}
		catch (IllegalArgumentException e) {
			return false;
		}
		Debug.println("success");
		return true;
	}
	
	private boolean postStatus(String status) {
		boolean retVal;
		
		try {
			twitter.updateStatus(status);
			Debug.print("Posted status: ");
			retVal = true;
		}
		catch (TwitterException e) {
			Debug.print("Failed to post status: ");
			retVal = false;
		}
		Debug.println(status);
		return retVal;
	}
	
	public int storeStatus(String status) {
		if (status.equals("") || status == null) {
			Debug.println("Nothing stored; empty or null status.");
			return -1;
		}
		else {
			int i_status = drafts.size();
			drafts.add(new String (status));
			Debug.println("Stored status " + i_status + ": " + drafts.get(i_status));
			writeDataToDisk();
			
			return i_status;
		}
	}
	
	public String getStoredStatus(int statusID) {
		return new String(drafts.get(statusID));
	}
	
	public void setStoredStatus(int statusID, String newValue) {
		if (newValue.equals("") || newValue == null) {
			Debug.println("empty or null new status; removing element");
			drafts.remove(statusID);
		}
		else {
			drafts.set(statusID, new String(newValue));
		}
		writeDataToDisk();
	}
	
	public String removeStoredStatus(int statusID) {
		String removedStatus = drafts.remove(statusID);
		writeDataToDisk();
		
		return removedStatus;
	}
	
	public boolean postStoredStatus(int statusID) {
		// TODO: can't assume posting will always succeed.
		boolean succeeded = postStatus(drafts.remove(statusID));
		writeDataToDisk();
		
		return succeeded;
	}
	
	public Object[] getStoredStatusesPreview(int numChars) {
		Object[] preview = drafts.toArray();
		for (int i = 0; i < preview.length; i++) {
			if (((String)preview[i]).length() > numChars) {
				preview[i] = ((String)preview[i]).substring(0, numChars) + '\u2026';
			}
		}
		return preview;
	}
	
	public int getNumStoredStatuses() {
		return drafts.size();
	}
	
	public boolean writeDataToDisk() {
		// TODO: make this delete any unnecessary files
		try {
			BufferedWriter indexFile = new BufferedWriter(new FileWriter(dataBasePath + "index.txt"));
			indexFile.write("OAuth/ConsumerKey" + confSeparator + oauth.consumerKey + '\n');
			indexFile.write("OAuth/ConsumerSecret" + confSeparator + oauth.consumerSecret + '\n');
			indexFile.write("OAuth/AccessToken" + confSeparator + oauth.accessToken + '\n');
			indexFile.write("OAuth/AccessTokenSecret" + confSeparator + oauth.accessTokenSecret + '\n');
			for (int i = 0; i < drafts.size(); i++) {
				String draftPathSuffix = i + ".txt";
				BufferedWriter draftFile = new BufferedWriter(new FileWriter(dataBasePath + draftPathSuffix));
				draftFile.write(drafts.get(i));
				draftFile.close();
				indexFile.write("DraftPath" + confSeparator + draftPathSuffix + '\n');
			}
			indexFile.close();
		}
		catch (IOException e) {
			return false;
		}
		return true;
	}
	
}
