import java.util.*;
import java.io.*;

// Twitter4j is the library used to log into and post to Twitter.
import twitter4j.Twitter;
import twitter4j.TwitterException;
import twitter4j.TwitterFactory;
import twitter4j.auth.*;
import twitter4j.conf.*;

public class TweetDraftsBackend {
	
	// Makes Twitter objects
	private TwitterFactory tf;
	// The Twitter object we use to interact with Twitter API. Generated by TwitterFactory.
	private Twitter twitter;
	
	// Base path to where the configuration files are stored.
	private String dataBasePath;
	// This character separates the configuration file key and data. Example:
	// key=data
	final char confSeparator = '=';
	
	// Did we get all the information we need to sign into Twitter?
	private boolean isInitialized;
	
	// The set of 4 OAuth tokens we need to access Twitter.
	private OAuthTokens oauth;
	// List of the drafts the user wants to post to Twitter eventually.
	private ArrayList<String> drafts;
	
	public TweetDraftsBackend() {
		this("data/");
	}
	
	public TweetDraftsBackend(String configPath) {
		// Construct ALL the objects!
		dataBasePath = new String(configPath);
		isInitialized = false;
		drafts = new ArrayList<String>();
		oauth = new OAuthTokens();
	}
	
	/**
	 * Try to load configuration files from disk. If all the OAuth tokens are loadable, automatically calls initTwitterObjs().
	 * @return true if everything was loaded successfully and Twitter can be used.
	 */
	public boolean loadDataFromDisk() {
		Debug.println("Loading data from disk.");
		// Prevent client classes from calling loadDataFromDisk() twice. They shouldn't do that.
		if (isInitialized) {
			Debug.println("Already initialized. Didn't load data again.");
			return isInitialized;
		}
		
		try {
			String path = dataBasePath + "index.txt";
			Debug.println("Trying to open " + path);
			Scanner config = new Scanner(new File(path));
			Debug.println("Opening succeeded.");
			
			// Load the config line by line. (Configuration files are newline-separated.)
			while (config.hasNextLine()) {
				Debug.println("Has next line.");
				String buf = config.nextLine();
				Debug.println("Got line from config: " + buf);
				// Will store the data type (such as Consumer Key) and the actual data.
				String type, data;
				
				// Find the index where the type ends and the data begins.
				int i_separator = buf.indexOf(confSeparator);
				
				// String.indexOf() returns -1 when it can't find the character we request.
				if (i_separator == -1) {
					Debug.println("That line is invalid.");
					// Abort the current line and load the next one.
					continue;
				}
				else {
					// Parse the buffer into its two components.
					type = buf.substring(0, i_separator);
					data = buf.substring(i_separator + 1);
					Debug.println("Parsed: " + type + ", " + data);
				}
				
				// Try to identify the data type in the current line of the configuration file. If identified, the data is saved.
				Debug.print("Matched: ");
				if (type.equals("OAuth/ConsumerKey")) {
					oauth.consumerKey = data;
					Debug.print("oauth.consumerKey");
				}
				else if (type.equals("OAuth/ConsumerSecret")) {
					oauth.consumerSecret = data;
					Debug.print("oauth.consumerSecret");
				}
				else if (type.equals("OAuth/AccessToken")) {
					oauth.accessToken = data;
					Debug.print("oauth.accessToken");
				}
				else if (type.equals("OAuth/AccessTokenSecret")) {
					oauth.accessTokenSecret = data;
					Debug.print("oauth.accessTokenSecret");
				}
				else if (type.equals("DraftPath")) {
					String draft = loadDraft(dataBasePath + data);
					if (draft != null) {
						drafts.add(draft);
					}
					Debug.print("draft");
				}
				else {
					Debug.print("none");
				}
				
				Debug.println("");
			}
			Debug.println("Done reading index file.");
		}
		catch (IOException e) {
			Debug.println("Can't open index file.");
		}
		
		// If we got all the keys from the configuration file.
		if (oauth.isComplete()) {
			isInitialized = initTwitterObjs();
			Debug.println("OAuth has all keys");
		}
		
		return isInitialized;
	}
	
	/**
	 * Load the entire contents of a text file from the disk.
	 * @param path The path to the file.
	 * @return The contents of the entire file if it exists. null if the file doesn't exist.
	 */
	private String loadDraft(String path) {
		// Initialize to empty string so that we can append to it.
		String draft = "";
		
		try {
			Scanner data = new Scanner(new File(path));
			// Load each line and append to our string.
			while (data.hasNextLine()) {
				draft += data.nextLine() + '\n';
			}
			Debug.println("loaded draft: " + draft);
		}
		// Where the code goes when the file doesn't exist or some other stupid thing.
		catch (IOException e) {
			draft = null;
			Debug.println("(empty)");
		}
		
		return draft;
	}
	
	/**
	 * Set the OAuth tokens for logging into Twitter. Call initTwitterObjs().
	 * @param tokens The OAuth new tokens to use.
	 * @return The previous OAuth tokens.
	 */
	public OAuthTokens setOAuthTokens(OAuthTokens tokens) {
		// Don't let client classes call this method more than they need to.
		if (isInitialized) {
			return null;
		}
		
		// Save the old tokens so we can return them.
		OAuthTokens oldTokens = oauth;
		
		oauth = tokens;
		initTwitterObjs();
		isInitialized = oauth.isComplete();
		
		return oldTokens;
	}
	
	/**
	 * Initialize the twitter4j objects.
	 * @return true on success. false otherwise.
	 */
	public boolean initTwitterObjs() {
		Debug.print("initTwitterObjs ");
		// Reject incomplete OAuth tokens.
		if (!oauth.isComplete()) {
			Debug.println("fail");
			return false;
		}
		
		// Save some configuration data.
		ConfigurationBuilder cb = new ConfigurationBuilder();
		cb.setDebugEnabled(Debug.isDebug)
		  .setUseSSL(true)
		  .setOAuthConsumerKey(oauth.consumerKey)
		  .setOAuthConsumerSecret(oauth.consumerSecret)
		  .setOAuthAccessToken(oauth.accessToken)
		  .setOAuthAccessTokenSecret(oauth.accessTokenSecret)
		  .setMediaProvider("imgly")
		;
		
		// ConfigurationBuilder class builds configuration to pass into TwitterFactory's constructor.
		tf = new TwitterFactory(cb.build());
		// Try to tell TwitterFactory to make us a Twitter objects.
		try {
			twitter = tf.getInstance();
		}
		catch (IllegalArgumentException e) {
			return false;
		}
		Debug.println("success");
		return true;
	}
	
	/**
	 * Internal method used to post things to Twitter.
	 * @param status The status to be posted.
	 * @return true on success. false otherwise.
	 */
	private boolean postStatus(String status) {
		boolean retVal;
		
		try {
			twitter.updateStatus(status);
			Debug.print("Posted status: ");
			retVal = true;
		}
		catch (TwitterException e) {
			Debug.print("Failed to post status: ");
			retVal = false;
		}
		Debug.println(status);
		return retVal;
	}
	
	/**
	 * Store a status to the drafts list. Call writeDataToDisk().
	 * @param status The status to be stored.
	 * @return The index at which the status was stored. -1 if the status was null or empty string.
	 */
	public int storeStatus(String status) {
		// Don't store empty or null strings.
		if (status.equals("") || status == null) {
			Debug.println("Nothing stored; empty or null status.");
			return -1;
		}
		else {
			// size of a list == last element + 1
			int i_status = drafts.size();
			drafts.add(new String (status));
			Debug.println("Stored status " + i_status + ": " + drafts.get(i_status));
			writeDataToDisk();
			
			return i_status;
		}
	}
	
	/**
	 * Get a copy of a draft.
	 * @param statusID The index of the status to be retrieved.
	 * @return A copy of the status at index statusID.
	 */
	public String getStoredStatus(int statusID) {
		return new String(drafts.get(statusID));
	}
	
	/**
	 * Update a draft. Call writeDataToDisk();
	 * @param statusID The index of the status to be updated.
	 * @param newValue The value to replace the status with.
	 */
	public void setStoredStatus(int statusID, String newValue) {
		// Don't update empty or null strings.
		if (newValue.equals("") || newValue == null) {
			Debug.println("empty or null new status; removing element");
			drafts.remove(statusID);
		}
		else {
			drafts.set(statusID, new String(newValue));
		}
		writeDataToDisk();
	}
	
	/**
	 * Remove a stored status. Call writeDataToDisk().
	 * @param statusID The index of the status to be removed.
	 * @return The status that was removed.
	 */
	public String removeStoredStatus(int statusID) {
		String removedStatus = drafts.remove(statusID);
		writeDataToDisk();
		
		return removedStatus;
	}
	
	/**
	 * Send a stored status to Twitter. Remove that status from the drafts list.
	 * @param statusID The index of the status to be posted.
	 * @return true on success. false otherwise.
	 */
	public boolean postStoredStatus(int statusID) {
		// TODO: can't assume posting will always succeed.
		boolean succeeded = postStatus(drafts.remove(statusID));
		writeDataToDisk();
		
		return succeeded;
	}
	
	/**
	 * Get the first few characters of a status in an Object array.
	 * @param numChars Number of characters each status should be truncated to.
	 * @return An array of the first numChars characters of each status, followed by a Unicode ellipses character if truncation happened (\u2026).
	 */
	public Object[] getStoredStatusesPreview(int numChars) {
		// Get the drafts ArrayList as an array.
		Object[] preview = drafts.toArray();
		for (int i = 0; i < preview.length; i++) {
			// If the status is too long.
			if (((String)preview[i]).length() > numChars) {
				// Replace with a truncated version appended with a Unicode ellipses character.
				preview[i] = ((String)preview[i]).substring(0, numChars) + '\u2026';
			}
		}
		return preview;
	}
	
	/**
	 * Get the number of drafts.
	 * @return The number of drafts.
	 */
	public int getNumStoredStatuses() {
		return drafts.size();
	}
	
	/**
	 * Save configuration and draft data to the data directory.
	 * @return true on success. false otherwise.
	 */
	public boolean writeDataToDisk() {
		// TODO: make this delete any unnecessary files
		try {
			// Open the index file. (Replaces the current index file.)
			BufferedWriter indexFile = new BufferedWriter(new FileWriter(dataBasePath + "index.txt"));
			
			// Save OAuth keys.
			indexFile.write("OAuth/ConsumerKey" + confSeparator + oauth.consumerKey + '\n');
			indexFile.write("OAuth/ConsumerSecret" + confSeparator + oauth.consumerSecret + '\n');
			indexFile.write("OAuth/AccessToken" + confSeparator + oauth.accessToken + '\n');
			indexFile.write("OAuth/AccessTokenSecret" + confSeparator + oauth.accessTokenSecret + '\n');
			
			// Save each draft as an individual text file.
			for (int i = 0; i < drafts.size(); i++) {
				// Construct the filepath of this draft's file.
				String draftPathSuffix = i + ".txt";
				// Open aforementioned file.
				BufferedWriter draftFile = new BufferedWriter(new FileWriter(dataBasePath + draftPathSuffix));
				// Get the appropriate draft from the drafts ArrayList and write it to the file in its entirety.
				draftFile.write(drafts.get(i));
				// Close the draft file.
				draftFile.close();
				// Add the draft file to the index.
				indexFile.write("DraftPath" + confSeparator + draftPathSuffix + '\n');
			}
			// Close the index file.
			indexFile.close();
		}
		catch (IOException e) {
			// If anything fails, this method will return false.
			return false;
		}
		return true;
	}
	
}
